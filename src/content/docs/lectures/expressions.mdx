---
title: "Expressions"
description: "Understand expressions in Python and how they represent data. This guide covers types, values, memory allocation, built-in data types, and the binary system, providing a solid foundation for programming."
sidebar:
  order: 5
---

import Latex from '../../../components/Latex.astro'

Programs are fundamentally sequences of instructions that manipulate data. To create a program, we must represent data, define operations to transform it, and manage storage for intermediate data during execution. In Python, an **expression** is any sequence of literals, variables, operators, or function calls that evaluates to a single value. The process of computing this value is called **evaluation**, and the value produced is referred to as the **result** of the expression.

In Python, expressions are the building blocks of data manipulation. Every expression has a **value** (the data it produces) and a **type** (the kind of data, such as an integer or string). Python is dynamically typed, meaning the type of an expression is determined at runtime and does not need to be explicitly declared, unlike in statically typed languages like C++. Expressions can represent simple values, such as numbers or strings, or more complex objects, like lists or custom objects. Let's explore an example using Python's version of the “Hello, World!” program:

```python
print("Hello, World!")
```

This line contains a key expression: the function call `print("Hello, World!")`. Let's break it down:

1. `"Hello, World!"`: A string literal, which is a sequence of characters.
   - **Type**: `str` (Python's string type).
   - **Value**: The sequence of characters `"Hello, World!"`.
2. `print(...)`: A built-in Python function that outputs data to the console.
   - **Type**: The `print` function itself is a built-in function object, but the expression `print("Hello, World!")` evaluates to `None` (Python's null equivalent).
   - **Value**: The `print` function outputs the string to the console and returns `None`.

:::note
In Python, the `print` function automatically appends a newline character (`\n`) to the output unless configured otherwise (e.g., using the `end` parameter). This differs from C++, where `std::endl` explicitly adds a newline and flushes the output stream. For simplicity, we treat the newline as part of the output behavior here.
:::

The `print("Hello, World!")` expression combines the string literal with the `print` function to produce console output. Unlike C++, Python does not use operators like `<<` for output; instead, it relies on functions like `print`.

## Memory

Expressions in Python have types and values, which must be stored in memory for the computer to process. Modern computers use the **binary numeric system** to represent all data internally. Every piece of data in a Python program, whether a number, string, or complex object, is ultimately stored as a sequence of binary digits (bits).

### Binary and Decimal Systems

The binary system is analogous to the decimal system used in everyday mathematics, but it differs in its **base**. The decimal system (base 10) uses ten digits `{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}` to represent numbers by combining them into sequences (e.g., 123). The binary system (base 2) uses only two digits `{0, 1}`, called **bits**, to represent numbers. By combining bits into sequences, binary can represent any value, just as decimal can.

If you're wondering how two symbols can represent arbitrarily large values, consider this.

A **tally mark system** (a unary numeric system with only one symbol) can represent any value by simply adding more marks. Similarly, having two symbols in binary provides even more flexibility to represent larger numbers with shorter sequences.

To illustrate, consider how numbers are represented in binary compared to decimal:

- `0` (binary) = $0$ (decimal)
- `1` (binary) = $1$ (decimal)
- `10` (binary) = $2$ (decimal)
- `11` (binary) = $3$ (decimal)
- `100` (binary) = $4$ (decimal)
- `101` (binary) = $5$ (decimal)
- `110` (binary) = $6$ (decimal)
- `111` (binary) = $7$ (decimal)
- `1000` (binary) = $8$ (decimal)
- `1001` (binary) = $9$ (decimal)

In the decimal system, place values are powers of 10 (1's, 10's, 100's, etc.). In binary, place values are powers of 2 (1's, 2's, 4's, 8's, etc.). To convert a binary number to decimal, multiply each bit by <Latex formula="2^n"/>, where <Latex formula="n"/> is the bit's position (starting from 0 on the right), and sum the results. For example, the binary number `10010` is calculated as:

<Latex formula="1 \cdot 2^4 + 0 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 = 16 + 0 + 0 + 2 + 0 = 18" inline = {false}/>

Thus, `10010` in binary equals `18` in decimal.

### Bytes and Storage

All data in a computer is stored as **bytes**, where a byte consists of **8 bits**. Even complex data types, such as strings or objects, are represented as sequences of bytes. For example, Python uses the **UTF-8** encoding (an extension of ASCII) to represent characters as numbers. The character `'A'` is encoded as the decimal value 65, which in binary is `01000001`. This allows computers to store and process textual data as binary.

Data storage occurs in two primary forms:

1. **Disk Storage**: Includes hard drives, SSDs, or USB drives, where data is stored persistently (it remains when the computer is off). Disk storage is designed for large capacity but is slower than other forms.
2. **Random Access Memory (RAM)**: Used for temporary storage during program execution, RAM is much faster but volatile (data is lost when the computer is powered off).

Python manages memory automatically through its **garbage collector**, which contrasts with C++'s manual memory management for certain types. However, the underlying binary representation remains the same.

## Expression Types

The type of an expression in Python determines how its value is interpreted and how much memory it requires. Python's dynamic typing means that types are inferred at runtime, but the type still governs:

1. **Storage requirements**: The number of bytes needed to store the value.
2. **Interpretation rules**: How the bytes are interpreted (e.g., as an integer, string, or boolean).

## Built-in Data Types

Python's equivalent to C++'s primitive data types are its **built-in types**, which are simpler and more flexible due to Python's dynamic typing. For this lecture, we focus on the most fundamental built-in types:

- `int`: Represents whole numbers (e.g., `42`, `-7`). Unlike C++, Python's `int` has no fixed size limit; it can grow arbitrarily large, constrained only by available memory.
- `float`: Represents floating-point numbers, including decimals (e.g., `3.14`). Python's `float` is equivalent to C++'s `double`, using 8 bytes for double-precision.
- `bool`: Represents truth values, `True` or `False`.
- `str`: Represents sequences of characters (e.g., `"Hello"`). In Python, strings are a built-in type, unlike C++, where strings are not primitive.
- `bytes`: Represents sequences of bytes, often used for raw binary data or encoded text (e.g., `b"Hello"`).

### Integral and Floating-Point Types

- **Integral types**: Include `int` and, in some contexts, `bytes`. These represent whole numbers or raw byte sequences.
- **Floating-point types**: Include `float`, which handles numbers with decimal points.

### Memory Allocation for Built-in Types

Unlike C++, where primitive types have compiler-dependent sizes, Python's built-in types have implementation-specific memory characteristics, managed by the Python interpreter (typically CPython). Common patterns include:

- `int`: Variable size, as Python's integers can grow arbitrarily large. A small integer (e.g., `42`) typically uses around 28 bytes in CPython due to object overhead, but this grows with larger numbers.
- `float`: Uses 8 bytes for double-precision floating-point numbers, similar to C++'s `double`.
- `bool`: Typically uses 28 bytes in CPython (due to object overhead), despite representing only `True` or `False`.
- `str`: Each character in a string uses 1–4 bytes, depending on the Unicode encoding (UTF-8 is default). For example, `"A"` uses 1 byte for the character plus object overhead.
- `bytes`: Each byte uses exactly 1 byte, plus object overhead.

:::note
Python's memory usage includes **object overhead** because every value is an object with metadata (e.g., type and reference count). This contrasts with C++, where primitive types have minimal overhead but fixed sizes. For example, a C++ `int` is typically 4 bytes, while a Python `int` includes additional bytes for flexibility.
:::

Expressions of different types may share the same binary representation but are interpreted differently. For example, the integer `65` and the string `"A"` both correspond to the binary `01000001` in memory (since `65` is the ASCII/UTF-8 code for `'A'`), but Python interprets them based on their type (`int` vs. `str`).

## Literals

A **literal** is a hard-coded value in a program. Python supports several types of literals, which directly correspond to its built-in types:

- `5`: An `int` literal.
- `5.1`: A `float` literal (all decimal numbers in Python are `float`).
- `True` / `False`: `bool` literals.
- `'A'`: A single-character `str` literal (Python uses single or double quotes for strings).
- `"Hello"`: A `str` literal.
- `b"Hello"`: A `bytes` literal (prefixing with `b` specifies a byte sequence).

Unlike C++, Python does not distinguish between `float` and `double` literals; all decimal literals are `float` (double-precision). Strings in Python are more straightforward, as both single and double quotes are equivalent (e.g., `'Hello'` and `"Hello"` are identical).
