---
title: Development Environment
description: TBD
sidebar:
  order: 1
---

:::caution
You don't have to use the development tools discussed below for this class. Feel free to use whatever tools you'd like. However, maintaining a working development environment is your responsibility. The TAs and I can only offer guidance when you're using tools that we're familiar with, so it's recommended that you stick with the below tools unless you're already familiar with other ones that will accomplish the same tasks.
:::

## Terminals

A terminal is a program that lets us interface with our computer via textual commands that get interpreted by another internal program called a shell. All of the software we write in this class will be text-based.

That means that our programs will not create windows or tabs with graphical user interfaces. Instead, we will run our programs by issuing textual commands in a terminal, and they will output responses through text in the terminal as well. Indeed, it's difficult to write, build, and run basic software without some sort of terminal.

Luckily, all modern operating systems come with one or more terminals installed. Follow the instructions below based on your operating system to become acquainted with your terminal.

### Accessing and Configuring Your Terminal

#### Windows: Powershell or Windows Terminal

Windows actually offers a few terminals / shells. The oldest one is the Command shell (CMD). Most people consider it to be obsolete, so I don't recommend using it. The Command shell was superseded by Powershell—lots of people use this one.
To access Powershell, simply search for “Powershell” in the Windows start menu. When you start it, a window should appear with a text cursor. You can now begin issuing textual commands to your computer by typing them and pressing enter. We'll learn about some commands shortly.
When you open Powershell for the first time, it will default to a certain configuration that most people don't like, so you may want to do some reconfiguration. If you right click on the window's menu bar (the top of the window) and click “Properties”, you can configure your terminal to your liking (e.g., background colors, font colors, font sizes, etc).

#### macOS: Terminal

Mac comes with a terminal by default. It's simply called “Terminal”, and you can find it by typing “Terminal” into the Mac Spotlight search (the magnifying glass at the topright corner of your screen). When you open your Mac Terminal for the first time, it will default to a certain configuration that most people don't like, so you may want to do some reconfiguration. In the menu bar, navigate to Terminal → Preferences, then navigate to the Profiles tab. From here, you can add new terminal profiles and modify existing ones. A profile is basically just a configuration of terminal settings. For most cases, it's sufficient to just modify the default profile (e.g., “Basic”). You can change default font sizes, colors, etc.

#### UNIX/Linux

If you're running a UNIX/Linux OS other than macOS (e.g., Ubuntu, FreeBSD, etc), then you probably already know what a terminal is. Most *nix terminals are extremely similar since the default shell is configured at a user level, so use whatever terminal you want.

:::tip[Some Other Terminal Programs]
In no specific order:

- [Alacritty](https://alacritty.org/)
- [iTerm2](https://iterm2.com/)
- [Hyper](https://hyper.is/)
- [Warp](https://www.warp.dev/)
- [Terminus](https://termius.com/)
- [Tabby](https://tabby.sh/)

Consider a cross-shell prompt, such as [Starship](https://starship.rs/), [Oh My Posh](https://ohmyposh.dev/), or [Powerline](https://github.com/powerline/powerline) to make your shell environment look good across platforms.
:::

## ENGR Servers

In some sense, you can think of a terminal as being similar to the Windows File Explorer or Mac Finder, but everything is text-based. By issuing textual commands in your terminal (i.e., typing them and pressing enter), you can navigate your file system, view files, edit files, and execute files (if they're executable). Indeed, anything you can do in a file explorer, you can also do in a terminal. But there are also lots of things that you can do in a terminal that you can't do in a file explorer. For this reason, terminals are indispensable
tools when you need to interface with your computer in intricate ways, such as in software development. 

However, we're going to do things a little differently in this course. Rather than issuing commands to our computer via the terminal, we're primarily going to be issuing commands to a different computer. In particular, OSU's College of Engineering has some big, fancy computers in the Kelley Engineering Center's server room. I'll refer to these computers as the ENGR servers. For this course, we're going to be doing all of our work on the ENGR servers. But there's one issue—the ENGR servers don't have monitors, mice, or keyboards attached to them (not to mention, they're behind locked doors, and only certain faculty and
staff are allowed physical access). So... How do we use them?

Well, it's simple—we're going to issue a single command to our computer's terminal to instruct our computer to connect to the ENGR servers remotely. At that point, we will be able to control the ENGR servers via a remote shell (i.e., we will be able to type commands into our terminal to control the ENGR servers). Note that this requires internet access.

Of course, connecting to and controlling OSU's ENGR servers requires authentication. First, you have to create an ENGR account if you don't already have one. To do this, navigate to [CoE TEACH](https://teach.engr.oregonstate.edu/teach.php), click “Create a new account”, and follow the instructions on screen to create your ENGR account.

Once you have an ENGR account setup, you should be able to connect to the ENGR servers from your terminal. To do this, type the following command into your terminal and press enter, substituting `<ONID>` with your ONID (e.g., mine is `ulbrical`):

```sh
ssh <ONID>@access.engr.oregonstate.edu
```

`ssh` stands for “Secure Shell”. It is a cryptographic network protocol that lets you connect to and control another computer remotely with a predefined user account and associated permissions.

At this point, your terminal should prompt you for a password (if not, then there's likely something wrong with your internet connection, or perhaps the ENGR servers are temporarily down). Type in your ONID password and press enter (i.e., the password you use to login to OSU services, like Canvas and Outlook). **Note that your password will be invisible as you type it.** That's okay—it's an intended security feature.

Your terminal should now prompt you to verify your login via Duo. If you have multiple Duo devices, then it will ask you which duo device you'd like to use for authentication. Type the desired device number and press enter. Approve the Duo push via your device. You should now be logged into the ENGR servers.

![A terminal logged into the ENGR servers](./terminal-engr-servers.png)

The ENGR servers run Linux, which means any commands you type into your terminal from here on out will be interpreted by the ENGR servers as Linux shell commands. You can configure your user account's Linux shell on TEACH, but the default one will work just fine. In addition, it's important to understand that, since your terminal is now controlling the ENGR servers rather than your own computer, you are now operating on the ENGR filespace. Soon, we will learn how to create and edit files on the ENGR server—understand that these files will be located on the ENGR servers and cannot be accessed trivially from your computer / Windows File Explorer / Mac Finder (if you wanted to transfer files between your computer and the ENGR
servers, you'd have to use a file transfer protocol like SFTP or SCP; feel free to Google it).

Some terminology: When we say something is local, or done locally, it means that it occurs directly on your computer. When we say something is remote, or done remotely, it means that it occurs on the ENGR servers (or whatever server you're connected to).

## The Prompt

The prompt is essentially a marker for where you can type commands. It appears every time the shell is ready to accept input. A simple example of a default prompt might look like this:

```sh
user@hostname:~$
```

### Components

The prompt typically provides useful contextual information. Here's a breakdown of common elements.

- Username (`user`): indicates the user currently logged into the system.
- Hostname (`hostname`): shows the name of the computer or server you're connected to, it's helpful in identifying the machine when working on multiple systems.
- Current Working Directory: shows the directory you're currently in, `~` means it's your `/home` directory, but it can be specific, e.g. `/var/log`.
- Shell Account Type: `$` means you're' a normal user, while `#` indicates elevated permissions (superuser/root).

### Interactive Features

- Tab Completion
- Command History
- Aliases

## Shell Commands

Now that our terminal is connected to the ENGR servers, we should learn how to use it. To summarize, here is a table briefly describing some important Linux shell commands:

| Command | Description |
| ------- | ----------- |
| `ssh` | |
| `pwd` | |
| `ls` | |
| `mkdir` | |
| `cd` | |
| `clear` | |
| `cp` | |
| `mv` | |
| `rm` | |
| `cat` | |
| `vim <path>` | |

### Basic Structure

```sh
command [options] [arguments]
```

#### `command`

The name of the program or script or utility that you want to execute.

Example: `ls` the command to list directory contents.

#### `options` (flags)

Options modify the behavior of the command. They are usually optional.

They often start with a `-` (single dash) for short options or `--` (double dash) for long options.

Example: `ls -l --color`, where `-l` enables long-format listing and `--color` highlights file types and permissions with colors (default is always).

You can also combine short options such as `ls -lsh`, where `-s` prints the allocated size of each file, in blocks, and `-h` makes things human-readable (when combined with `-s`).

#### `arguments`

Inputs to the command, such as file names, directories, or specific data to operate on.

Example:

```sh
cat myfile.txt
``` 

where `myfile.txt` is the argument to the `cat` command, which concatenates file(s) to the standard output.

Commands can accept multiple arguments:

```sh
cp file1.txt file2.txt destination/
```

where `file1.txt` and `file2.txt` are source files, and `destination/` is the target directory.

#### Combining `options` and `arguments`

Options and arguments can be combined in various ways, depending on the command syntax.

```sh
tar -czf archive.tar.gz file1 file2
```

where `-czf` is a combination of options for creating (c), compressing (z), and specifying a file (f), `archive.tar.gz` is the argument specifying the output file, and `file1` and `file2` are the files to archive.

### Additional Concepts

#### Pipes

#### Redirection

#### Subcommands

#### Environment Variables

#### Command Order and Logic

#### Miscellaneous

`.` `..` etc.

## Text Editors: `vim`, `nano`

TBD