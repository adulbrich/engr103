---
title: Development Environment
description: "Set up your development environment for Python programming. Learn how to use terminals, access OSU ENGR servers, navigate the file system, and edit files with vim. This guide ensures you're ready for efficient coding."
sidebar:
  order: 1
---

:::caution
You don't have to use the development tools discussed below for this class. Feel free to use whatever tools you'd like. However, maintaining a working development environment is your responsibility. The TAs and I can only offer guidance when you're using tools that we're familiar with, so it's recommended that you stick with the below tools unless you're already familiar with other ones that will accomplish the same tasks.
:::


Setting up a robust development environment is a critical first step for programming in Python. This guide provides a comprehensive walkthrough to configure your tools for writing, editing, and running Python code efficiently. You'll learn how to use a terminal to interact with your computer, connect to the Oregon State University (OSU) ENGR servers, navigate the file system, and edit files using `vim`. The objective is to equip you with a reliable setup for coding in Python, whether you're working on your local machine or the ENGR servers. While the tools outlined here are recommended for consistency and support in this course, you're welcome to use alternative tools if you're confident in their configuration. However, the teaching staff can offer the most effective assistance when you use the tools described below, as these are the ones we're familiar with.

## Terminals

A terminal is a text-based interface that enables you to interact with your computer by typing commands, which are processed by an internal program called a shell. In this course, all Python programs will be text-based, meaning they won't generate graphical interfaces like windows or tabs. Instead, you'll execute your Python scripts by entering commands in a terminal, and their output will appear as text in the same terminal. Proficiency in using a terminal is essential for writing, running, and managing Python code, particularly when working on remote servers like the ENGR servers at OSU.

Every modern operating system includes at least one terminal application. The following sections detail how to access and configure a terminal based on your operating system, preparing you to issue commands and work with Python effectively.

### Accessing and Configuring Your Terminal

#### Windows: PowerShell or Windows Terminal

Windows offers several terminal options, but the legacy Command Prompt (CMD) is outdated and not recommended. PowerShell is a modern, widely used terminal suitable for this course. To open PowerShell, search for “PowerShell” in the Windows Start menu. A window will appear with a text cursor, ready for you to type commands and press Enter to execute them. You'll explore essential commands later in this guide.

When you first launch PowerShell, its default appearance (e.g., font size, colors) may not be optimal. To customize it, right-click the title bar at the top of the PowerShell window and select “Properties.” You can adjust settings like background color, font size, and text color to create a more comfortable environment for coding in Python. Taking time to configure these settings early enhances your terminal experience.

#### macOS: Terminal

On macOS, the default terminal application is simply called “Terminal.” You can access it by typing “Terminal” into the Spotlight search (the magnifying glass in the top-right corner of your screen). Upon opening Terminal, you'll see a text-based interface with default settings that you may wish to adjust for better usability. To customize Terminal, navigate to **Terminal → Preferences** and select the **Profiles** tab. A profile defines a set of terminal settings, such as font size, colors, and background. You can modify the default profile (e.g., “Basic”) or create a new one to suit your preferences. These adjustments ensure the terminal is visually clear and comfortable for extended coding sessions.

#### UNIX/Linux

If you're using a UNIX or Linux distribution other than macOS (e.g., Ubuntu, Fedora, or Debian), you're likely familiar with terminals. Most Linux distributions provide terminals like GNOME Terminal, Konsole, or xterm, and the default shell (e.g., Bash or Zsh) is configured at the user level. You can use any terminal you prefer, as they all function similarly for issuing commands and running Python scripts. If you're new to Linux, the default terminal provided by your distribution is sufficient for this course.

:::tip[Some Other Terminal Programs]
In no specific order:

- [Ghostty](https://ghostty.org/)
- [Alacritty](https://alacritty.org/)
- [iTerm2](https://iterm2.com/)
- [Hyper](https://hyper.is/)
- [Warp](https://www.warp.dev/)
- [Terminus](https://termius.com/)
- [Tabby](https://tabby.sh/)

Consider a cross-shell prompt, such as [Starship](https://starship.rs/), [Oh My Posh](https://ohmyposh.dev/), or [Powerline](https://github.com/powerline/powerline) to make your shell environment look good across platforms.
:::


## ENGR Servers

A terminal functions as a text-based equivalent of graphical file explorers like Windows File Explorer or macOS Finder. By typing commands and pressing Enter, you can navigate directories, create or edit files, and execute Python scripts. Unlike graphical explorers, terminals provide advanced functionality critical for software development, such as precise control over file operations and the ability to run scripts efficiently. In this course, you'll primarily use a terminal to interact with remote computers—specifically, the ENGR servers located in the Kelley Engineering Center at OSU. These servers are powerful Linux machines designed for computational tasks, providing a standardized environment for running Python code.

The ENGR servers lack physical monitors, keyboards, or mice, and access to the server room is restricted to authorized personnel. Instead, you'll connect to these servers remotely using your computer's terminal. By issuing a single command, your terminal establishes a secure connection over the internet, granting access to a remote shell on the ENGR servers. This allows you to control the servers as if you were physically present, running commands and managing files directly on the remote system.

To access the ENGR servers, you need an ENGR account. If you don't have one, visit the [CoE TEACH](https://teach.engr.oregonstate.edu/teach.php) website, click “Create a new account,” and follow the instructions to set up your account. Once your account is active and you have an internet connection, you can connect to the servers using the following command in your terminal, replacing `<ONID>` with your ONID username (e.g., `ulbrical`):

```bash
ssh <ONID>@access.engr.oregonstate.edu
```

The `ssh` command uses the Secure Shell protocol to establish a secure connection to the ENGR servers. When you run this command, you'll be prompted to enter your ONID password (the same one used for OSU services like Canvas or Outlook). For security, your password won't appear as you type—this is expected behavior. After entering your password, you'll need to authenticate via Duo two-factor authentication. If you have multiple Duo devices, select the appropriate one by typing its number, then approve the Duo push notification on your device.

Upon successful authentication, your terminal will display a welcome message, indicating you're logged into the ENGR servers, which run a Linux operating system. From this point, all commands you type will be executed on the remote server, interpreted as Linux shell commands. The default shell configuration on the ENGR servers is suitable for this course, but you can customize it via the TEACH platform if desired.

When working on the ENGR servers, all file operations (e.g., creating, editing, or deleting files) occur on the remote server, not your local computer. Files you create won't appear in your local file explorer unless you transfer them using tools like SFTP (Secure File Transfer Protocol) or SCP (Secure Copy Protocol). For example, a Python script saved on the ENGR servers remains there until you explicitly transfer it to your local machine. If you need to transfer files, you can find tutorials online for SFTP or SCP, but this course focuses on working directly on the servers.

To clarify terminology: “local” refers to your personal computer, while “remote” refers to the ENGR servers. Understanding this distinction is crucial, as you'll be managing files and running Python scripts on the remote servers throughout the course.

## The Prompt

The prompt is the text marker in your terminal that indicates where you can type commands, appearing whenever the shell is ready for input. On the ENGR servers, a typical prompt might look like this:

```bash
user@hostname:~$ 
```

The prompt provides contextual information to help you navigate your environment. It typically includes your username (e.g., your ONID), the hostname of the server, and the current working directory (e.g., `~` for your home directory). The `$` symbol indicates you're logged in as a regular user, while a `#` would indicate elevated (root) privileges, which you won't need for this course. 

The ENGR servers prompt is customized and will show the **hostname**, **current working directory**, and the **command history number**. For example:

```bash
flip2 ~ 501$
```

The shell offers interactive features to enhance your workflow. Tab completion allows you to press the Tab key to auto-complete commands, file names, or directories, reducing typing errors. Command history lets you access previously entered commands using the up and down arrow keys, making it easy to reuse or modify commands. You can also create aliases—shortcuts for longer commands—by configuring your shell, though this is optional for beginners.

## Shell Commands

With your terminal connected to the ENGR servers, you need to master Linux shell commands to navigate and manage files effectively. These commands enable you to explore directories, create and manipulate files, and execute Python scripts. A terminal operates within a specific directory, called the **working directory**, analogous to the folder open in a graphical file explorer. To check your current working directory, use:

```bash
pwd
```

The `pwd` command (print working directory) displays the full path of your current directory, such as `/nfs/stak/users/<ONID>`. Upon logging into the ENGR servers, your working directory defaults to your home directory, a user-specific space tied to your ONID username.

To list the files and directories in your working directory, use:

```bash
ls
```

The `ls` command displays/**list**s the contents of the current directory, often with color-coding to distinguish files from directories. 

To navigate/**change** to a different **directory**, use:

```bash
cd <path>
```

For example, `cd python_code` moves you into a directory named `python_code` within the current directory. To return to your home directory, run `cd` or `cd ~`. To move up one directory level, use `cd ..`. 

Paths can be **absolute** (starting from the root, e.g., `/nfs/stak/users/<ONID>/python_code`) or **relative** (relative to the current directory, e.g., `python_code`). 

Special shortcuts include:

-  `.` (current directory), 
- `..` (parent directory), and 
- `~` (home directory).

To **create**/**make** a new **directory**, use:

```bash
mkdir <path>
```

For example, `mkdir python_code` creates a directory named `python_code`. To create nested directories, add the `-p` flag: `mkdir -p python_code/project1` creates both `python_code` and `project1` if they don't exist.

To **copy** a file, use:

```bash
cp <source_path> <destination_path>
```

For example, `cp script.py script_backup.py` creates a copy of `script.py`. To copy a directory and its contents, add the `-r` flag: `cp -r python_code python_code_backup`.

To **move** or **rename** a file or directory, use:

```bash
mv <source_path> <destination_path>
```

For example, `mv script.py new_script.py` renames the file, while `mv script.py python_code/` moves it into the `python_code` directory.

To **delete**/**remove** a file, use:

```bash
rm <path>
```

For example, `rm script.py` deletes `script.py`. To delete a directory and its contents, use `rm -r python_code`. Be cautious with `rm`, as deleted files cannot be recovered easily.

To view a file's contents without editing it, use:

```bash
cat <path>
```

For example, `cat script.py` displays the contents of `script.py`. You can also concatenate multiple files: `cat file1.py file2.py` prints their contents in sequence.

To run a Python script, use:

```bash
python <script_path>
```

For example, `python script.py` executes `script.py` using the Python interpreter on the ENGR servers. Unlike C++ programs, which require compilation, Python scripts are interpreted directly, making this command the primary way to run your code.

These commands—`pwd`, `ls`, `cd`, `mkdir`, `cp`, `mv`, `rm`, `cat`, and `python`—form the foundation of terminal-based file management. By mastering them, you can navigate the file system, manage your Python scripts, and execute your programs efficiently on the ENGR servers.

## Anatomy of a Terminal Command

When you type a command in the terminal, it follows a specific structure. Understanding this structure helps you write effective commands and utilize options and arguments correctly. A typical command format looks like this:

```sh
command [options] [arguments]
```

- **`command`**: The main command you want to execute, such as `ls`, `cd`, or `python`.
- **`options`**: Flags that modify the command's behavior, usually prefixed with a hyphen (e.g., `-l`, `-r`). Options are optional and can be combined (e.g., `-lr`).
- **`arguments`**: Additional information required by the command, such as file names or paths. Arguments specify what the command should operate on, like a specific file or directory.

The brackets (`[ ]`) indicate that options and arguments are optional. You can run a command with just the command name, or you can include one or more options and arguments as needed.

You can consult the manual pages for any command by typing `man <command>` in the terminal. For example, `man ls` displays the manual for the `ls` command, explaining its options and usage. You can exit the manual by pressing `q`.

Let's revisit the `ls` command as an example:

```sh
ls -l /path/to/directory
```

- **`ls`** is the command to list directory contents.
- **`-l`** is an option that tells `ls` to display detailed information about each file, such as permissions, owner, size, and modification date.
- **`/path/to/directory`** is an argument specifying the directory to list. If omitted, `ls` defaults to the current directory.

## Advanced Shell Concepts

In the previous section, we covered essential file and directory management commands to help you navigate and manipulate your system. Now, let's explore more advanced terminal concepts that enhance the power and flexibility of the command line: pipes, redirection, subcommands, environment variables, and command order and logic.

These concepts allow you to chain commands, manage output and input efficiently, and work with complex logic in the shell. Let's dive in.

### Pipes

A pipe connects the output of one command directly to the input of another, enabling you to chain commands together to perform complex tasks efficiently. The pipe operator (`|`) makes it easy to process data without creating intermediate files.

Example:

```bash
ls | grep "example"
```
- `ls` lists the files in the directory.
- `grep "example"` filters the output, showing only files or directories that contain “example” in their name.

Pipes are powerful for combining commands to handle streams of text, like filtering log files, processing data, or chaining utilities.

### Redirection

Redirection allows you to control where a command's output goes or where it takes input from. This is particularly useful for saving output to files or providing input to commands.

- Output Redirection (`>`) redirects the output of a command to a file, overwriting the file if it exists.

```bash
echo "Hello, World!" > output.txt
```

- Append Output (`>>`) appends the output of a command to a file without overwriting it.

```bash
echo "Another line" >> output.txt
```

- Input Redirection (`<`) redirects a file as input to a command.

```bash
wc -l < input.txt
```

Here, the `wc -l` command counts the lines in `input.txt`.

Redirection enables you to store results, feed data into commands, or even create complex workflows with minimal effort.

### Environment Variables

Environment variables are dynamic values stored in the shell's environment that can influence how commands and programs operate. They're often used to store system-wide configurations or user-specific settings.

Common Environment Variables:
- `PATH`: Directories where the shell looks for executable files.
- `HOME`: The current user's home directory.
- `USER`: The name of the current user.

```bash
echo $HOME
```

This command prints the value of the `HOME` environment variable, which should return something like `/nfs/stak/users/<ONID>` on the ENGR servers.

You can also define your own variables:

```bash
MY_VAR="Hello, World!"
echo $MY_VAR
```

Environment variables are invaluable for customizing your shell, managing system settings, and scripting.

### Command Order and Logic

The shell allows you to execute commands in specific orders and combine them using **logical operators** for advanced control. This lets you define conditions for when commands should run.

- `&&` executes the next command only if the previous command succeeds.

```bash
mkdir new_dir && cd new_dir
```

- `||` executes the next command only if the previous command fails.

```bash
cd nonexistent_dir || echo "Directory not found"
```

- `;` executes commands sequentially, regardless of success or failure.

```bash
echo "First" ; echo "Second"
```
These operators provide fine-grained control over the flow of commands, enabling you to automate and script tasks with precision.

### Subshell

A subshell is a separate child process created by the shell to execute commands. It inherits the environment of the parent shell but operates independently. When a subshell runs a command or a group of commands, changes made in the subshell (like variable assignments or directory changes) do not affect the parent shell.

```bash
(cd /tmp && ls)
```

- `( ... )` runs the enclosed commands in a subshell.
- Here, the subshell changes to `/tmp` and lists its contents.
- The parent shell remains in its original directory after the subshell completes.

### Command Substitution

Command substitution is a way to capture the output of a command and use it in another command. This is achieved using the `$()` syntax, making it a crucial tool for dynamic command generation and scripting. When using `$()`, the shell spawns a subshell to execute the command inside the `$()` and replaces the substitution with the command's output.

```bash
echo "Today is $(date)"
echo "Current directory: $(pwd)"
```

## Text Editor: vim

To write and edit Python code on the ENGR servers, you'll use a terminal-based text editor. While editors like `nano` and `emacs` are available, this course focuses on `vim`, a powerful editor that runs directly in the terminal. Unlike graphical editors, `vim` relies on text-based commands, making it ideal for remote server work where graphical interfaces aren't available.

To open or create a Python file in `vim`, use:

```bash
vim <path>
```

For example, `vim script.py` opens `script.py` for editing. If the file doesn't exist, `vim` creates it. Upon opening, `vim` starts in **normal mode**, where you issue commands like saving or quitting. To write code, switch to **insert mode** by pressing `i`. You can then type Python code, such as:

```python
print("Hello, world!")
```

:::tip
Vim hotkeys and commands are case-sensitive. For example, `i` (lowercase) and `I` (uppercase) both switch to insert mode, but other commands may differ. Ensure caps lock is off to avoid errors.
:::

To save and exit, return to normal mode by pressing `Esc`, then type `:wq` and press Enter. This writes/saves the file and quits `vim`. Other useful `vim` commands include:

- `:w` to save without quitting.
- `:q` to quit without saving (use `:q!` to force quit without saving changes).
- `:set nu` to display line numbers, useful for debugging Python code.
- `:set mouse=a` to enable mouse support (disabled by default).
- `:syntax on` to enable syntax highlighting (usually enabled by default, but may need to be enabled in certain circumstances), improving code readability.

You can customize `vim` by creating a `.vimrc` file in your home directory:

```bash
vim ~/.vimrc
```

Add settings like:

```vim
set nu
set mouse=a
syntax on
set tabstop=4
set shiftwidth=4
set expandtab
```

These settings enable line numbers, mouse support, syntax highlighting, and configure indentation to follow Python's standard four-space convention. Save the file with `:wq`. To verify its creation, use `ls -a ~` to list hidden files, including `.vimrc`.

To check a file's contents without editing, use:

```bash
cat script.py
```

This displays `script.py`'s contents, such as the `print("Hello, world!")` line. The `cat` command is useful for quick checks or concatenating multiple files.

By mastering `vim` and these shell commands, you're equipped to create, edit, and run Python code efficiently on the ENGR servers, aligning with the course's expectations for a terminal-based development environment.
