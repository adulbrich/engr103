// generated by GPT-5.2
export type PrimitiveType = 'int' | 'double' | 'bool' | 'char';

export type VarKind = 'value' | 'ref';

export interface ModelConfig {
  intSize: number;
  doubleSize: number;
  boolSize: number;
  charSize: number;
  baseAddress: number;
  evaluationOrder: 'left-to-right';
}

export interface MemoryVar {
  id: string;
  name: string;
  kind: VarKind;
  type: PrimitiveType;
  size: number;
  address: number;
  scopeDepth: number;
  alive: boolean;
  value: number | boolean | string | null;
  refTarget?: string;
}

export type MemoryEvent =
  | { type: 'alloc'; varId: string }
  | { type: 'write'; varId: string }
  | { type: 'dealloc'; varId: string }
  | { type: 'bindRef'; varId: string; targetVarId: string };

export interface TraceStateSnapshot {
  config: ModelConfig;
  scopeDepth: number;
  nextAddress: number;
  vars: MemoryVar[];
}

export interface TraceStep {
  id: string;
  lineIndex: number; // 0-based
  explanation: string;
  events: MemoryEvent[];
  state: TraceStateSnapshot;
}

export interface TraceResult {
  ok: true;
  lines: string[];
  steps: TraceStep[];
  config: ModelConfig;
}

export interface TraceError {
  ok: false;
  lines: string[];
  message: string;
  lineIndex?: number;
  hint?: string;
}

export type TraceOutput = TraceResult | TraceError;

const DEFAULT_CONFIG: ModelConfig = {
  intSize: 4,
  doubleSize: 8,
  boolSize: 1,
  charSize: 1,
  baseAddress: 0x1000,
  evaluationOrder: 'left-to-right',
};

type Token =
  | { kind: 'number'; value: number }
  | { kind: 'ident'; value: string }
  | { kind: 'op'; value: '+' | '-' | '*' | '/' }
  | { kind: 'lparen' }
  | { kind: 'rparen' };

type CompareOp = '==' | '!=' | '<' | '<=' | '>' | '>=';

function stripLineComment(line: string): string {
  const idx = line.indexOf('//');
  return idx >= 0 ? line.slice(0, idx) : line;
}

function tokenizeExpr(expr: string): Token[] {
  const tokens: Token[] = [];
  let i = 0;
  const s = expr.trim();

  while (i < s.length) {
    const ch = s[i];
    if (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
      i += 1;
      continue;
    }

    if (ch === '(') {
      tokens.push({ kind: 'lparen' });
      i += 1;
      continue;
    }

    if (ch === ')') {
      tokens.push({ kind: 'rparen' });
      i += 1;
      continue;
    }

    if (ch === '+' || ch === '-' || ch === '*' || ch === '/') {
      tokens.push({ kind: 'op', value: ch });
      i += 1;
      continue;
    }

    if (/[0-9]/.test(ch)) {
      let j = i + 1;
      while (j < s.length && /[0-9]/.test(s[j])) j += 1;
      const num = Number(s.slice(i, j));
      tokens.push({ kind: 'number', value: num });
      i = j;
      continue;
    }

    if (/[A-Za-z_]/.test(ch)) {
      let j = i + 1;
      while (j < s.length && /[A-Za-z0-9_]/.test(s[j])) j += 1;
      const ident = s.slice(i, j);
      tokens.push({ kind: 'ident', value: ident });
      i = j;
      continue;
    }

    throw new Error(`Unexpected character in expression: '${ch}'`);
  }

  return tokens;
}

class ExprParser {
  private tokens: Token[];
  private index = 0;
  private env: Map<string, number>;

  constructor(tokens: Token[], env: Map<string, number>) {
    this.tokens = tokens;
    this.env = env;
  }

  parse(): number {
    const v = this.parseAddSub();
    if (this.index !== this.tokens.length) {
      throw new Error('Unexpected tokens at end of expression');
    }
    return v;
  }

  private peek(): Token | undefined {
    return this.tokens[this.index];
  }

  private consume(): Token {
    const t = this.tokens[this.index];
    if (!t) throw new Error('Unexpected end of expression');
    this.index += 1;
    return t;
  }

  private parseAddSub(): number {
    let v = this.parseMulDiv();
    while (true) {
      const t = this.peek();
      if (!t || t.kind !== 'op' || (t.value !== '+' && t.value !== '-')) break;
      this.consume();
      const rhs = this.parseMulDiv();
      v = t.value === '+' ? v + rhs : v - rhs;
    }
    return v;
  }

  private parseMulDiv(): number {
    let v = this.parsePrimary();
    while (true) {
      const t = this.peek();
      if (!t || t.kind !== 'op' || (t.value !== '*' && t.value !== '/')) break;
      this.consume();
      const rhs = this.parsePrimary();
      if (t.value === '/') {
        if (rhs === 0) throw new Error('Division by zero');
        v = Math.trunc(v / rhs);
      } else {
        v = v * rhs;
      }
    }
    return v;
  }

  private parsePrimary(): number {
    const t = this.consume();
    if (t.kind === 'number') return t.value;
    if (t.kind === 'ident') {
      const v = this.env.get(t.value);
      if (v === undefined) throw new Error(`Unknown identifier '${t.value}'`);
      return v;
    }
    if (t.kind === 'lparen') {
      const v = this.parseAddSub();
      const r = this.consume();
      if (r.kind !== 'rparen') throw new Error('Expected )');
      return v;
    }
    throw new Error('Expected number, identifier, or (expr)');
  }
}

function typeSize(type: PrimitiveType, config: ModelConfig): number {
  switch (type) {
    case 'int':
      return config.intSize;
    case 'double':
      return config.doubleSize;
    case 'bool':
      return config.boolSize;
    case 'char':
      return config.charSize;
  }
}

function cloneVars(vars: MemoryVar[]): MemoryVar[] {
  return vars.map((v) => ({ ...v }));
}

function snapshot(config: ModelConfig, scopeDepth: number, nextAddress: number, vars: MemoryVar[]): TraceStateSnapshot {
  return {
    config,
    scopeDepth,
    nextAddress,
    vars: cloneVars(vars),
  };
}

function normalizeStatement(line: string): string {
  const noComment = stripLineComment(line);
  return noComment.trim();
}

function removeTrailingSemicolon(stmt: string): string {
  return stmt.endsWith(';') ? stmt.slice(0, -1).trim() : stmt;
}

function parseBoolLiteral(raw: string): boolean | null {
  if (raw === 'true') return true;
  if (raw === 'false') return false;
  return null;
}

function parseCharLiteral(raw: string): string | null {
  // Very small subset: 'a' style only (no escapes)
  const m = raw.match(/^'(.)'$/);
  return m ? m[1] : null;
}

function parsePrimitiveLiteral(type: PrimitiveType, rawExpr: string, envInts: Map<string, number>): number | boolean | string {
  const raw = rawExpr.trim();
  if (type === 'bool') {
    const b = parseBoolLiteral(raw);
    if (b === null) throw new Error(`Expected bool literal 'true' or 'false', got '${raw}'`);
    return b;
  }
  if (type === 'char') {
    const c = parseCharLiteral(raw);
    if (c === null) throw new Error(`Expected char literal like 'a', got '${raw}'`);
    return c;
  }
  if (type === 'double') {
    const n = Number(raw);
    if (!Number.isFinite(n)) throw new Error(`Expected double literal, got '${raw}'`);
    return n;
  }

  // int expression
  const tokens = tokenizeExpr(raw);
  const parser = new ExprParser(tokens, envInts);
  return parser.parse();
}

function buildIntEnv(vars: MemoryVar[]): Map<string, number> {
  const env = new Map<string, number>();
  for (const v of vars) {
    if (!v.alive) continue;
    if (v.kind === 'value' && v.type === 'int') {
      if (typeof v.value === 'number') {
        env.set(v.name, v.value);
      }
    }
    if (v.kind === 'ref') {
      const target = vars.find((x) => x.id === v.refTarget);
      if (target && target.alive && target.kind === 'value' && target.type === 'int' && typeof target.value === 'number') {
        env.set(v.name, target.value);
      }
    }
  }
  return env;
}

function buildBoolEnv(vars: MemoryVar[]): Map<string, boolean> {
  const env = new Map<string, boolean>();
  for (const v of vars) {
    if (!v.alive) continue;
    if (v.kind === 'value' && v.type === 'bool') {
      if (typeof v.value === 'boolean') {
        env.set(v.name, v.value);
      }
    }
    if (v.kind === 'ref') {
      const target = vars.find((x) => x.id === v.refTarget);
      if (target && target.alive && target.kind === 'value' && target.type === 'bool' && typeof target.value === 'boolean') {
        env.set(v.name, target.value);
      }
    }
  }
  return env;
}

function evalComparison(op: CompareOp, left: number, right: number): boolean {
  switch (op) {
    case '==':
      return left === right;
    case '!=':
      return left !== right;
    case '<':
      return left < right;
    case '<=':
      return left <= right;
    case '>':
      return left > right;
    case '>=':
      return left >= right;
  }
}

function evalCondition(condRaw: string, vars: MemoryVar[]): boolean {
  const cond = condRaw.trim();
  const b = parseBoolLiteral(cond);
  if (b !== null) return b;

  const boolEnv = buildBoolEnv(vars);
  if (/^[A-Za-z_]\w*$/.test(cond) && boolEnv.has(cond)) {
    return boolEnv.get(cond) ?? false;
  }

  const m = cond.match(/^(.+?)\s*(==|!=|<=|>=|<|>)\s*(.+)$/);
  if (m) {
    const leftExpr = m[1] ?? '';
    const op = m[2] as CompareOp;
    const rightExpr = m[3] ?? '';
    const envInts = buildIntEnv(vars);
    const left = Number(parsePrimitiveLiteral('int', leftExpr, envInts));
    const right = Number(parsePrimitiveLiteral('int', rightExpr, envInts));
    return evalComparison(op, left, right);
  }

  throw new Error(`Unsupported condition '${cond}'`);
}

function resolveLValue(vars: MemoryVar[], name: string): MemoryVar | null {
  // Prefer innermost alive binding
  for (let i = vars.length - 1; i >= 0; i -= 1) {
    const v = vars[i];
    if (!v.alive) continue;
    if (v.name === name) return v;
  }
  return null;
}

let stepCounter = 0;

export function generateCppTeachingTrace(code: string, partialConfig?: Partial<ModelConfig>): TraceOutput {
  const config: ModelConfig = { ...DEFAULT_CONFIG, ...partialConfig };
  const lines = code.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

  const vars: MemoryVar[] = [];
  const scopes: string[][] = [[]];
  let scopeDepth = 0;
  let nextAddress = config.baseAddress;

  const steps: TraceStep[] = [];

  function pushStep(lineIndex: number, explanation: string, events: MemoryEvent[]) {
    const id = `step_${stepCounter++}`;
    steps.push({
      id,
      lineIndex,
      explanation,
      events,
      state: snapshot(config, scopeDepth, nextAddress, vars),
    });
  }

  function allocValue(lineIndex: number, type: PrimitiveType, name: string): MemoryVar {
    const existing = resolveLValue(vars, name);
    if (existing && existing.scopeDepth === scopeDepth) {
      throw new Error(`Redeclaration of '${name}' in the same scope`);
    }

    const size = typeSize(type, config);
    const v: MemoryVar = {
      id: `var_${name}_${vars.length}`,
      name,
      kind: 'value',
      type,
      size,
      address: nextAddress,
      scopeDepth,
      alive: true,
      value: null,
    };

    vars.push(v);
    scopes[scopes.length - 1]!.push(v.id);
    nextAddress += size;

    pushStep(
      lineIndex,
      `Allocate ${type} '${name}' in the current stack frame (uninitialized).`,
      [{ type: 'alloc', varId: v.id }]
    );

    return v;
  }

  function writeValue(lineIndex: number, v: MemoryVar, value: number | boolean | string, extra?: string) {
    v.value = value;
    pushStep(lineIndex, extra ? `Write ${v.name} = ${String(value)}. ${extra}` : `Write ${v.name} = ${String(value)}.`, [
      { type: 'write', varId: v.id },
    ]);
  }

  function bindRef(lineIndex: number, type: PrimitiveType, name: string, targetName: string): MemoryVar {
    const target = resolveLValue(vars, targetName);
    if (!target) throw new Error(`Unknown identifier '${targetName}'`);
    if (target.kind === 'ref' && target.refTarget) {
      const resolved = vars.find((x) => x.id === target.refTarget);
      if (resolved) {
        // allow binding to a ref; treat as binding to ultimate target
        return bindRef(lineIndex, type, name, resolved.name);
      }
    }
    if (target.type !== type) {
      throw new Error(`Type mismatch: cannot bind ${type}& '${name}' to ${target.type} '${targetName}'`);
    }

    const refVar: MemoryVar = {
      id: `var_${name}_${vars.length}`,
      name,
      kind: 'ref',
      type,
      size: 0,
      address: target.address,
      scopeDepth,
      alive: true,
      value: null,
      refTarget: target.id,
    };

    vars.push(refVar);
    scopes[scopes.length - 1]!.push(refVar.id);

    pushStep(
      lineIndex,
      `Bind reference '${name}' to '${targetName}' (no new storage allocated; '${name}' aliases the same address).`,
      [{ type: 'bindRef', varId: refVar.id, targetVarId: target.id }]
    );

    return refVar;
  }

  function deallocScope(lineIndex: number) {
    const ids = scopes.pop();
    if (!ids) return;
    for (let i = ids.length - 1; i >= 0; i -= 1) {
      const id = ids[i]!;
      const v = vars.find((x) => x.id === id);
      if (!v || !v.alive) continue;
      v.alive = false;
      pushStep(lineIndex, `End of scope: '${v.name}' lifetime ends; its stack storage is released.`, [{ type: 'dealloc', varId: v.id }]);
    }
  }

  function nextNonEmptyLineIndex(fromIndex: number): number {
    for (let i = fromIndex; i < lines.length; i += 1) {
      const s = normalizeStatement(lines[i] ?? '');
      if (s.length > 0) return i;
    }
    return lines.length;
  }

  function findMatchingCloseBrace(openBraceLineIndex: number): number {
    let depth = 0;
    for (let i = openBraceLineIndex + 1; i < lines.length; i += 1) {
      const s = normalizeStatement(lines[i] ?? '');
      if (s === '{') {
        depth += 1;
        continue;
      }
      if (s === '}') {
        if (depth === 0) return i;
        depth -= 1;
      }
    }
    throw new Error('Unmatched {');
  }

  function executeSimpleStatement(lineIndex: number, stmt0: string) {
    const stmt = removeTrailingSemicolon(stmt0);

    // Reference declaration: int& r = x
    {
      const m = stmt.match(/^(?:const\s+)?(int|double|bool|char)\s*&\s*([A-Za-z_]\w*)\s*=\s*([A-Za-z_]\w*)$/);
      if (m) {
        const type = m[1] as PrimitiveType;
        const name = m[2]!;
        const target = m[3]!;
        bindRef(lineIndex, type, name, target);
        return;
      }
    }

    // Value declaration: int x; or int x = 3
    {
      const m = stmt.match(/^(?:const\s+)?(int|double|bool|char)\s+([A-Za-z_]\w*)\s*(?:=\s*(.+))?$/);
      if (m) {
        const type = m[1] as PrimitiveType;
        const name = m[2]!;
        const initRaw = m[3];

        const v = allocValue(lineIndex, type, name);

        if (initRaw !== undefined) {
          const initExpr = initRaw.trim().replace(/^\{\s*/, '').replace(/\s*\}$/, '');
          const envInts = buildIntEnv(vars);
          const value = parsePrimitiveLiteral(type, initExpr, envInts);
          writeValue(lineIndex, v, value, 'Initialization happens immediately after allocation.');
        }

        return;
      }
    }

    // Increment shorthand: i++ / ++i
    {
      const m = stmt.match(/^([A-Za-z_]\w*)\+\+$|^\+\+([A-Za-z_]\w*)$/);
      if (m) {
        const name = (m[1] ?? m[2]) as string;
        const lhs = resolveLValue(vars, name);
        if (!lhs) throw new Error(`Unknown identifier '${name}'`);
        const target = lhs.kind === 'ref' && lhs.refTarget ? vars.find((x) => x.id === lhs.refTarget) ?? null : lhs;
        if (!target) throw new Error(`Dangling reference '${name}'`);
        if (target.type !== 'int') throw new Error(`Unsupported ++ on non-int '${name}'`);
        if (typeof target.value !== 'number') throw new Error(`Cannot ++ '${name}' because it is uninitialized`);
        const next = target.value + 1;
        pushStep(lineIndex, `Evaluate ++ to a temporary value (${String(next)}).`, []);
        writeValue(lineIndex, target, next);
        return;
      }
    }

    // Assignment: x = expr
    {
      const m = stmt.match(/^([A-Za-z_]\w*)\s*=\s*(.+)$/);
      if (m) {
        const lhsName = m[1]!;
        const rhsExpr = m[2]!;

        const lhs = resolveLValue(vars, lhsName);
        if (!lhs) throw new Error(`Unknown identifier '${lhsName}'`);

        const target = lhs.kind === 'ref' && lhs.refTarget ? vars.find((x) => x.id === lhs.refTarget) ?? null : lhs;
        if (!target) throw new Error(`Dangling reference '${lhsName}'`);
        if (!target.alive) throw new Error(`Cannot assign to '${lhsName}' because its lifetime has ended`);

        const envInts = buildIntEnv(vars);
        const value = parsePrimitiveLiteral(target.type, rhsExpr, envInts);

        pushStep(lineIndex, `Evaluate RHS expression to a temporary value (${String(value)}).`, []);
        writeValue(lineIndex, target, value);
        return;
      }
    }

    throw new Error('Unsupported statement');
  }

  function executeRange(startLine: number, endLineExclusive: number) {
    let i = startLine;
    while (i < endLineExclusive) {
      const rawLine = lines[i] ?? '';
      const stmt0 = normalizeStatement(rawLine);
      if (stmt0.length === 0) {
        i += 1;
        continue;
      }

      if (stmt0 === '{') {
        scopeDepth += 1;
        scopes.push([]);
        pushStep(i, 'Enter a new scope block.', []);
        i += 1;
        continue;
      }

      if (stmt0 === '}') {
        if (scopeDepth === 0) throw new Error('Unmatched }');
        deallocScope(i);
        scopeDepth -= 1;
        pushStep(i, 'Exit scope block.', []);
        i += 1;
        continue;
      }

      // if (cond)
      {
        const m = stmt0.match(/^if\s*\((.*)\)\s*$/);
        if (m) {
          const condRaw = m[1] ?? '';
          const thenOpen = nextNonEmptyLineIndex(i + 1);
          if (thenOpen >= lines.length || normalizeStatement(lines[thenOpen] ?? '') !== '{') {
            throw new Error("Expected '{' on its own line after if (...)");
          }
          const thenClose = findMatchingCloseBrace(thenOpen);

          const afterThen = nextNonEmptyLineIndex(thenClose + 1);
          const hasElse = afterThen < lines.length && normalizeStatement(lines[afterThen] ?? '') === 'else';

          let elseOpen = -1;
          let elseClose = -1;
          if (hasElse) {
            elseOpen = nextNonEmptyLineIndex(afterThen + 1);
            if (elseOpen >= lines.length || normalizeStatement(lines[elseOpen] ?? '') !== '{') {
              throw new Error("Expected '{' on its own line after else");
            }
            elseClose = findMatchingCloseBrace(elseOpen);
          }

          const condValue = evalCondition(condRaw, vars);
          pushStep(i, `Evaluate if condition (${condRaw.trim()}) -> ${condValue ? 'true' : 'false'}.`, []);

          if (condValue) {
            pushStep(i, 'Condition true: execute then-branch.', []);
            executeRange(thenOpen, thenClose + 1);
            if (hasElse) pushStep(afterThen, 'Skip else-branch.', []);
          } else {
            pushStep(i, hasElse ? 'Condition false: execute else-branch.' : 'Condition false: skip then-branch.', []);
            if (hasElse) {
              executeRange(elseOpen, elseClose + 1);
            }
          }

          i = hasElse ? elseClose + 1 : thenClose + 1;
          continue;
        }
      }

      if (stmt0 === 'else') {
        throw new Error("Unexpected 'else' (must follow a matching if)");
      }

      // while (cond)
      {
        const m = stmt0.match(/^while\s*\((.*)\)\s*$/);
        if (m) {
          const condRaw = m[1] ?? '';

          const bodyOpen = nextNonEmptyLineIndex(i + 1);
          if (bodyOpen >= lines.length || normalizeStatement(lines[bodyOpen] ?? '') !== '{') {
            throw new Error("Expected '{' on its own line after while (...)");
          }
          const bodyClose = findMatchingCloseBrace(bodyOpen);

          const maxIters = 200;
          let iter = 0;
          while (true) {
            if (iter++ > maxIters) throw new Error('Loop iteration limit exceeded (possible infinite loop)');
            const condValue = evalCondition(condRaw, vars);
            pushStep(i, `Evaluate while condition (${condRaw.trim()}) -> ${condValue ? 'true' : 'false'}.`, []);
            if (!condValue) break;
            executeRange(bodyOpen, bodyClose + 1);
          }

          i = bodyClose + 1;
          continue;
        }
      }

      // do { ... } while (cond);
      {
        if (stmt0 === 'do') {
          const bodyOpen = nextNonEmptyLineIndex(i + 1);
          if (bodyOpen >= lines.length || normalizeStatement(lines[bodyOpen] ?? '') !== '{') {
            throw new Error("Expected '{' on its own line after do");
          }
          const bodyClose = findMatchingCloseBrace(bodyOpen);

          const whileLine = nextNonEmptyLineIndex(bodyClose + 1);
          const whileStmt = normalizeStatement(lines[whileLine] ?? '');
          const m = whileStmt.match(/^while\s*\((.*)\)\s*;?\s*$/);
          if (!m) {
            throw new Error("Expected 'while (cond);' after do { ... }");
          }
          const condRaw = m[1] ?? '';

          const maxIters = 200;
          let iter = 0;
          while (true) {
            if (iter++ > maxIters) throw new Error('Loop iteration limit exceeded (possible infinite loop)');
            pushStep(i, 'Execute do-while body (runs at least once).', []);
            executeRange(bodyOpen, bodyClose + 1);

            const condValue = evalCondition(condRaw, vars);
            pushStep(whileLine, `Evaluate do-while condition (${condRaw.trim()}) -> ${condValue ? 'true' : 'false'}.`, []);
            if (!condValue) break;
          }

          i = whileLine + 1;
          continue;
        }
      }

      // for (init; cond; inc)
      {
        const m = stmt0.match(/^for\s*\((.*)\)\s*$/);
        if (m) {
          const header = (m[1] ?? '').trim();
          const parts = header.split(';').map((p) => p.trim());
          if (parts.length !== 3) {
            throw new Error('Unsupported for-loop header (expected init; cond; inc)');
          }
          const [initPart, condPart, incPart] = parts;

          const bodyOpen = nextNonEmptyLineIndex(i + 1);
          if (bodyOpen >= lines.length || normalizeStatement(lines[bodyOpen] ?? '') !== '{') {
            throw new Error("Expected '{' on its own line after for (...)");
          }
          const bodyClose = findMatchingCloseBrace(bodyOpen);

          // Model C++ for-loop init-scope: variables declared in init live through the loop.
          scopeDepth += 1;
          scopes.push([]);
          pushStep(i, 'Enter for-loop scope.', []);

          if (initPart.length > 0) {
            executeSimpleStatement(i, initPart);
          }

          const maxIters = 200;
          let iter = 0;
          while (true) {
            if (iter++ > maxIters) throw new Error('Loop iteration limit exceeded (possible infinite loop)');
            const condValue = condPart.length === 0 ? true : evalCondition(condPart, vars);
            pushStep(i, `Evaluate for-loop condition (${condPart.trim()}) -> ${condValue ? 'true' : 'false'}.`, []);
            if (!condValue) break;

            executeRange(bodyOpen, bodyClose + 1);

            if (incPart.length > 0) {
              executeSimpleStatement(i, incPart);
            }
          }

          // End of for-loop init-scope; align deallocation to the closing brace of the loop body.
          deallocScope(bodyClose);
          scopeDepth -= 1;
          pushStep(bodyClose, 'Exit for-loop scope.', []);

          i = bodyClose + 1;
          continue;
        }
      }

      executeSimpleStatement(i, stmt0);
      i += 1;
    }
  }

  try {
    executeRange(0, lines.length);

    // End of top-level scope: deallocate everything still alive.
    // Use a virtual line index one past the last snippet line so UI wrappers
    // (e.g., `int main() { ... }`) can highlight the closing brace.
    deallocScope(lines.length);

    return { ok: true, lines, steps, config };
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    return {
      ok: false,
      lines,
      message,
      hint:
        "Supported subset: { } blocks, primitive local declarations (int/double/bool/char), initialization, assignments, T& references, if/else, for, while, and do/while (with braces on their own lines). No pointers/heaps/functions yet.",
    };
  }
}
